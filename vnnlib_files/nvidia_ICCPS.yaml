# Example of verifying an ONNX model with VNNLIB general specifications
model:
  # Assuming you have cloned the vnncomp2021 repository: https://github.com/stanleybak/vnncomp2021
  #onnx_path: /home/adi2440/Desktop/ICRA_2025/ICRA/scripts/FINAL_ICCPS/main/3_NUV/Nvidia_formal.onnx
  onnx_path: /home/adi2440/Desktop/ICCPS_2025/ICRA/scripts/FINAL_ICCPS/main/3_NUV/formal_Nvidia.onnx
  input_shape: [-1,8]

specification:
  # VNNLIB file specification.
  vnnlib_path: /home/adi2440/Desktop/ICCPS_2025/ICRA/scripts/FINAL_ICCPS/main/5_verification_scripts/specifications/perform/bright_0.2_phi_3.vnnlib
solver:
  batch_size: 2000  # Number of subdomains to compute in parallel in bound solver. Decrease if you run out of memory.
  bound_prop_method: beta-crown
  beta-crown:
    lr_alpha: 0.01    # Learning rate for alpha in alpha-CROWN. The default (0.1) is typically ok.

bab:
  timeout: 2000  # Timeout threshold for branch and bound. Increase for verifying more points.
  branching:  # Parameters for branching heuristics.
    reduceop: min  # Reduction function for the branching heuristic scores, min or max. Using max can be better on some models.
    method: kfsb  # babsr is fast but less accurate; fsb is slow but most accurate; kfsb is usually a balance.
    candidates: 50  # Number of candidates to consider in fsb and kfsb. More leads to slower but better branching. 3 is typically good enough.

attack:
  pgd_steps: 50000
  pgd_restarts: 500
  pgd_early_stop: false
  enable_mip_attack: true
